<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Admin PN</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="page">
    <header class="topbar">
      <div>
        <div class="eyebrow">Narzędzie sprzedażowe</div>
        <h1>Admin mapowań PN</h1>
        <p class="subtitle">Backup i przywracanie mapowań.</p>
      </div>
      <div class="top-actions">
        <nav class="top-menu" aria-label="Główne menu">
          <a class="top-menu-link" href="index.html">
            <span class="top-menu-icon" aria-hidden="true">
              <img src="resources/icon-calc.svg" alt="">
            </span>
            <span>Kalkulator</span>
          </a>
          <a class="top-menu-link" href="pn-mappings.html">
            <span class="top-menu-icon" aria-hidden="true">
              <img src="resources/icon-mapping.svg" alt="">
            </span>
            <span>Mapowania</span>
          </a>
          <a class="top-menu-link" href="mapping-builder.html">
            <span class="top-menu-icon" aria-hidden="true">
              <img src="resources/icon-mapping.svg" alt="">
            </span>
            <span>Kreator</span>
          </a>
          <button id="themeToggleBtn" class="top-menu-toggle icon-only" aria-label="Zmień motyw">
            <span class="top-menu-icon" aria-hidden="true">
              <img class="theme-icon theme-icon-dark" src="resources/icon-dark-mode.svg" alt="">
              <img class="theme-icon theme-icon-light" src="resources/icon-light-mode.svg" alt="">
            </span>
          </button>
        </nav>
        <div class="top-admin-badge" title="Panel admina" aria-label="Panel admina">
          <span class="top-menu-icon" aria-hidden="true">
            <img src="resources/icon-admin.svg" alt="">
          </span>
          <span>Admin</span>
        </div>
      </div>
    </header>

    <section class="app-card admin-shell">
      <div class="admin-header-row">
        <div>
          <div class="eyebrow">Panel narzędzi</div>
          <h2>Kontrola mapowań</h2>
          <p class="subtitle">Backupy, przywracanie i szybkie testy w jednym miejscu.</p>
        </div>
      </div>

      <div class="admin-grid">
        <div class="admin-card">
          <h3>Backup mapowań</h3>
          <p>Zapisz bieżące mapowania do pliku JSON. Przyda się przed większymi zmianami.</p>
          <div class="admin-actions">
            <button type="button" id="downloadBackupBtn">Pobierz backup JSON</button>
            <button type="button" id="downloadFullBackupBtn">Pobierz pełny backup</button>
          </div>
          <div class="admin-meta">Ostatni backup: <span id="lastBackupValue">brak</span></div>
        </div>

        <div class="admin-card">
          <h3>Backup logów</h3>
          <p>Bezpieczna kopia historii działań w KV. Pozwala szybko odtworzyć logi.</p>
          <div class="backup-status">Status: <strong id="logsBackupStatus">Sprawdzam…</strong></div>
          <div class="admin-actions">
            <button type="button" id="logsBackupRefreshBtn">Utwórz backup teraz</button>
            <button type="button" id="logsBackupRestoreBtn">Przywróć z backupu</button>
          </div>
          <div class="admin-meta">Ostatni backup logów: <span id="logsBackupTs">brak</span></div>
        </div>

        <div class="admin-card">
          <h3>Przywracanie</h3>
          <p>Wczytaj plik JSON i nadpisz mapowania w bazie.</p>
          <div class="admin-actions">
            <button type="button" id="restoreBackupBtn">Przywróć z pliku</button>
          </div>
          <div class="admin-meta warn">Uwaga: przywrócenie backupu nadpisuje bieżące mapowania.</div>
        </div>

        <div class="admin-card">
          <h3>Aktualizacja logów</h3>
          <p>Podnieś starsze zgłoszenia do nowego formatu (kind/reportId).</p>
          <div class="admin-actions">
            <button type="button" id="migrateLogsBtn">Migracja logów</button>
            <button type="button" id="dedupLogsBtn">Scal duplikaty</button>
          </div>
          <div class="admin-meta">Pokaże listę zmian przed zapisaniem.</div>
        </div>


        <div class="admin-card admin-card-wide">
          <h3>Status mapowań</h3>
          <div class="admin-kpis">
            <div class="admin-kpi">
              <span class="label">PN exact</span>
              <strong id="exactCount">—</strong>
            </div>
            <div class="admin-kpi">
              <span class="label">Wzorce</span>
              <strong id="patternCount">—</strong>
            </div>
            <div class="admin-kpi">
              <span class="label">Razem</span>
              <strong id="totalCount">—</strong>
            </div>
          </div>
          <div class="admin-meta">Ostatnia synchronizacja: <span id="lastSyncValue">—</span></div>
        </div>

        <div class="admin-card admin-card-wide">
          <details id="reportSection">
            <summary class="report-summary">
              <span>Zgłoszenia</span>
              <span class="report-count" id="reportCount">0</span>
            </summary>
            <p>Raporty z wyszukiwarki PN oraz błędy działania strony.</p>
            <div class="report-filter">
              <label for="reportFilter">Filtr zgłoszeń</label>
              <select id="reportFilter">
                <option value="all">Wszystkie</option>
                <option value="mapping">Tylko mapowania</option>
                <option value="ui" selected>Tylko błędy strony</option>
              </select>
            </div>
            <div id="reportList" class="report-list">Brak zgłoszeń.</div>
          </details>
        </div>

        <div class="admin-card admin-card-wide">
          <details id="logSection">
            <summary class="report-summary">
              <span>Historia operacji</span>
              <span class="report-count" id="logCount">0</span>
            </summary>
            <p>Lista ostatnich działań na backupach i zapisach (IP + data).</p>
            <div class="admin-log-controls">
              <div class="admin-log-field">
                <label for="logTypeFilter">Typ</label>
                <select id="logTypeFilter">
                  <option value="all" selected>Wszystko</option>
                  <option value="backup-all">Backup (wszystkie)</option>
                  <option value="backup">Backup</option>
                  <option value="backup-full">Backup pełny</option>
                  <option value="backup-logs">Backup logów</option>
                  <option value="restore-logs">Przywrócenie logów</option>
                  <option value="update">Update</option>
                  <option value="mapping">Mapowania</option>
                  <option value="mapping-report">Zgłoszenia</option>
                  <option value="calc">Przeliczenia</option>
                  <option value="search">Wyszukiwania</option>
                </select>
              </div>
              <div class="admin-log-field admin-log-field-wide">
                <label for="logQuery">Szukaj (IP / FP / UA / miasto)</label>
                <input type="text" id="logQuery" placeholder="np. 185.152, fp-123, Chrome, Warsaw">
              </div>
              <div class="admin-log-field">
                <label for="logPageSize">Na stronę</label>
                <select id="logPageSize">
                  <option value="10">10</option>
                  <option value="20" selected>20</option>
                  <option value="50">50</option>
                </select>
              </div>
              <div class="admin-log-field">
                <label>&nbsp;</label>
                <button type="button" id="logRefreshBtn">Odśwież logi</button>
              </div>
            </div>
            <div id="adminLogList" class="admin-log-list">Brak danych.</div>
            <div class="admin-log-pagination">
              <button type="button" id="logPrevBtn">Wstecz</button>
              <span id="logPageInfo">Strona 1 / 1</span>
              <button type="button" id="logNextBtn">Dalej</button>
            </div>
          </details>
        </div>

        <div class="admin-card admin-card-wide">
          <h3>Wskazówki</h3>
          <ul class="admin-list">
            <li>`x` = jedna cyfra, `*` = jeden dowolny znak, `+` = dowolny ciąg znaków.</li>
            <li>Po dużej edycji wykonaj backup, żeby nie stracić reguł.</li>
            <li>Backup przechowuj lokalnie z nazwą daty dla szybkiego przywrócenia.</li>
            <li>Jeśli coś wygląda podejrzanie, sprawdź logi IP i User-Agent.</li>
            <li>Dodawaj wzorce od najbardziej szczegółowych do ogólnych.</li>
          </ul>
        </div>
      </div>

      <input type="file" id="backupFileInput" accept="application/json" style="display: none;">
    </section>
  </div>

  <div id="mappingToastStack" class="mapping-toast-stack" role="status" aria-live="polite"></div>

  <div id="reportConfirmModal" class="mapping-modal" style="display: none;">
    <div class="mapping-modal-card" role="dialog" aria-modal="true" aria-labelledby="reportConfirmTitle">
      <div class="mapping-modal-header">
        <strong id="reportConfirmTitle">Potwierdź mapowanie</strong>
        <button type="button" id="reportConfirmClose" aria-label="Zamknij">×</button>
      </div>
      <div class="mapping-modal-body">
        <div class="report-meta" id="reportConfirmInfo"></div>
        <label for="reportConfirmKey">PN lub wzorzec</label>
        <input type="text" id="reportConfirmKey" maxlength="64">
        <label for="reportConfirmVendor">Producent</label>
        <input type="text" id="reportConfirmVendor" maxlength="64">
        <label for="reportConfirmType">Typ wpisu</label>
        <select id="reportConfirmType">
          <option value="auto" selected>Auto (PN lub wzorzec)</option>
          <option value="exact">PN exact</option>
          <option value="pattern">Wzorzec</option>
        </select>
        <label for="reportConfirmStatus">Status (dla błędów działania strony)</label>
        <select id="reportConfirmStatus">
          <option value="resolved" selected>Resolved</option>
          <option value="on-hold">On hold</option>
        </select>
        <label for="reportConfirmNote">Uwagi admina</label>
        <textarea id="reportConfirmNote" rows="2" placeholder="Opcjonalne uwagi admina"></textarea>
      </div>
      <div class="mapping-modal-actions confirm-actions">
        <button type="button" id="reportConfirmCancel">Anuluj</button>
        <button type="button" id="reportConfirmApply">Zastosuj</button>
      </div>
    </div>
  </div>

  <div id="reportDismissModal" class="mapping-modal" style="display: none;">
    <div class="mapping-modal-card" role="dialog" aria-modal="true" aria-labelledby="reportDismissTitle">
      <div class="mapping-modal-header">
        <strong id="reportDismissTitle">Usuń zgłoszenie?</strong>
        <button type="button" id="reportDismissClose" aria-label="Zamknij">×</button>
      </div>
      <div class="mapping-modal-body">
        <p id="reportDismissMessage">Czy na pewno chcesz usunąć to zgłoszenie?</p>
      </div>
      <div class="mapping-modal-actions confirm-actions">
        <button type="button" id="reportDismissCancel">Anuluj</button>
        <button type="button" id="reportDismissApply" class="btn-danger">Usuń</button>
      </div>
    </div>
  </div>

  <div id="reportRetypeModal" class="mapping-modal" style="display: none;">
    <div class="mapping-modal-card" role="dialog" aria-modal="true" aria-labelledby="reportRetypeTitle">
      <div class="mapping-modal-header">
        <strong id="reportRetypeTitle">Zmień typ zgłoszenia</strong>
        <button type="button" id="reportRetypeClose" aria-label="Zamknij">×</button>
      </div>
      <div class="mapping-modal-body">
        <p id="reportRetypeMessage">Czy na pewno chcesz zmienić typ tego zgłoszenia?</p>
      </div>
      <div class="mapping-modal-actions confirm-actions">
        <button type="button" id="reportRetypeCancel">Anuluj</button>
        <button type="button" id="reportRetypeApply">Zmień typ</button>
      </div>
    </div>
  </div>

  <div id="migrateLogsModal" class="mapping-modal" style="display: none;">
    <div class="mapping-modal-card" role="dialog" aria-modal="true" aria-labelledby="migrateLogsTitle">
      <div class="mapping-modal-header">
        <strong id="migrateLogsTitle">Migracja logów</strong>
        <button type="button" id="migrateLogsClose" aria-label="Zamknij">×</button>
      </div>
      <div class="mapping-modal-body">
        <p id="migrateLogsSummary">Ładuję podgląd zmian…</p>
        <div id="migrateLogsList" class="migrate-list"></div>
      </div>
      <div class="mapping-modal-actions confirm-actions">
        <button type="button" id="migrateLogsCancel">Anuluj</button>
        <button type="button" id="migrateLogsApply">Zastosuj migrację</button>
      </div>
    </div>
  </div>

  <script src="ui-theme.js"></script>
  <script src="pn-mappings.js"></script>
  <script>
    if (window.UITheme?.init) window.UITheme.init();

    const toastStack = document.getElementById('mappingToastStack');
    const downloadBackupBtn = document.getElementById('downloadBackupBtn');
    const downloadFullBackupBtn = document.getElementById('downloadFullBackupBtn');
    const restoreBackupBtn = document.getElementById('restoreBackupBtn');
    const migrateLogsBtn = document.getElementById('migrateLogsBtn');
    const logsBackupStatus = document.getElementById('logsBackupStatus');
    const logsBackupTs = document.getElementById('logsBackupTs');
    const logsBackupRefreshBtn = document.getElementById('logsBackupRefreshBtn');
    const logsBackupRestoreBtn = document.getElementById('logsBackupRestoreBtn');
    const backupFileInput = document.getElementById('backupFileInput');
    const lastBackupValue = document.getElementById('lastBackupValue');
    const lastSyncValue = document.getElementById('lastSyncValue');
    const adminLogList = document.getElementById('adminLogList');
    const logTypeFilter = document.getElementById('logTypeFilter');
    const logQuery = document.getElementById('logQuery');
    const logPageSize = document.getElementById('logPageSize');
    const logPrevBtn = document.getElementById('logPrevBtn');
    const logNextBtn = document.getElementById('logNextBtn');
    const logPageInfo = document.getElementById('logPageInfo');
    const logRefreshBtn = document.getElementById('logRefreshBtn');
    const reportList = document.getElementById('reportList');
    const reportCount = document.getElementById('reportCount');
    const reportFilter = document.getElementById('reportFilter');
    const logCount = document.getElementById('logCount');
    const reportConfirmModal = document.getElementById('reportConfirmModal');
    const reportConfirmClose = document.getElementById('reportConfirmClose');
    const reportConfirmCancel = document.getElementById('reportConfirmCancel');
    const reportConfirmApply = document.getElementById('reportConfirmApply');
    const reportConfirmInfo = document.getElementById('reportConfirmInfo');
    const reportConfirmKey = document.getElementById('reportConfirmKey');
    const reportConfirmVendor = document.getElementById('reportConfirmVendor');
    const reportConfirmType = document.getElementById('reportConfirmType');
    const reportConfirmStatus = document.getElementById('reportConfirmStatus');
    const reportConfirmNote = document.getElementById('reportConfirmNote');
    const reportDismissModal = document.getElementById('reportDismissModal');
    const reportDismissClose = document.getElementById('reportDismissClose');
    const reportDismissCancel = document.getElementById('reportDismissCancel');
    const reportDismissApply = document.getElementById('reportDismissApply');
    const reportDismissMessage = document.getElementById('reportDismissMessage');
    const reportRetypeModal = document.getElementById('reportRetypeModal');
    const reportRetypeClose = document.getElementById('reportRetypeClose');
    const reportRetypeCancel = document.getElementById('reportRetypeCancel');
    const reportRetypeApply = document.getElementById('reportRetypeApply');
    const reportRetypeMessage = document.getElementById('reportRetypeMessage');
    const migrateLogsModal = document.getElementById('migrateLogsModal');
    const migrateLogsClose = document.getElementById('migrateLogsClose');
    const migrateLogsCancel = document.getElementById('migrateLogsCancel');
    const migrateLogsApply = document.getElementById('migrateLogsApply');
    const migrateLogsSummary = document.getElementById('migrateLogsSummary');
    const migrateLogsList = document.getElementById('migrateLogsList');
    const dedupLogsBtn = document.getElementById('dedupLogsBtn');
    const patternSeedInput = document.getElementById('patternSeedInput');
    const patternGenerateBtn = document.getElementById('patternGenerateBtn');
    const patternSuggestions = document.getElementById('patternSuggestions');
    const patternResult = document.getElementById('patternResult');
    const patternVendorSelect = document.getElementById('patternVendorSelect');
    const patternVendor = document.getElementById('patternVendor');
    const patternApplyBtn = document.getElementById('patternApplyBtn');
    const patternStripSpecial = document.getElementById('patternStripSpecial');
    const patternPreferPlus = document.getElementById('patternPreferPlus');
    let migrateMode = 'full';
    let pendingReportApply = null;
    let pendingReportDismiss = null;
    let pendingReportRetype = null;
    const exactCountEl = document.getElementById('exactCount');
    const patternCountEl = document.getElementById('patternCount');
    const totalCountEl = document.getElementById('totalCount');
    const ADMIN_LAST_BACKUP_KEY = 'adminLastBackup';
    const ADMIN_LAST_SYNC_KEY = 'adminLastSync';
    let logsCache = [];
    let reportsCache = [];
    let totalLogs = null;
    let logPage = 1;
    let logsBackupCache = null;

    function normalizePn(value) {
      return String(value || '').replace(/\s+/g, '').toUpperCase();
    }

    function normalizeSeed(value, stripSpecial) {
      const base = normalizePn(value);
      if (!stripSpecial) return base;
      return base.replace(/[^A-Z0-9-]/g, '');
    }

    function longestCommonPrefix(values) {
      if (!values.length) return '';
      let prefix = values[0];
      for (let i = 1; i < values.length; i += 1) {
        const val = values[i];
        let j = 0;
        while (j < prefix.length && j < val.length && prefix[j] === val[j]) j += 1;
        prefix = prefix.slice(0, j);
        if (!prefix) break;
      }
      return prefix;
    }

    function buildPositionalPattern(values) {
      if (!values.length) return '';
      const length = values[0].length;
      if (!values.every((v) => v.length === length)) return '';
      const chars = [];
      for (let i = 0; i < length; i += 1) {
        const column = values.map((v) => v[i]);
        const allSame = column.every((c) => c === column[0]);
        if (allSame) {
          chars.push(column[0]);
          continue;
        }
        const allDigits = column.every((c) => /\d/.test(c));
        chars.push(allDigits ? 'x' : '*');
      }
      return chars.join('');
    }

    function buildPrefixPattern(values) {
      const prefix = longestCommonPrefix(values);
      if (prefix.length < 2) return '';
      return `${prefix}+`;
    }

    function longestCommonSuffix(values) {
      if (!values.length) return '';
      let suffix = values[0];
      for (let i = 1; i < values.length; i += 1) {
        const val = values[i];
        let j = 0;
        while (j < suffix.length && j < val.length && suffix[suffix.length - 1 - j] === val[val.length - 1 - j]) {
          j += 1;
        }
        suffix = suffix.slice(suffix.length - j);
        if (!suffix) break;
      }
      return suffix;
    }

    function buildSuffixPattern(values) {
      const suffix = longestCommonSuffix(values);
      if (suffix.length < 2) return '';
      return `+${suffix}`;
    }

    function buildSegmentPattern(values) {
      const parts = values.map((v) => v.split('-'));
      const lengths = new Set(parts.map((p) => p.length));
      if (lengths.size !== 1) return '';
      const segCount = parts[0].length;
      const segments = [];
      for (let i = 0; i < segCount; i += 1) {
        const column = parts.map((p) => p[i]);
        const allSame = column.every((c) => c === column[0]);
        if (allSame) {
          segments.push(column[0]);
          continue;
        }
        const allDigits = column.every((c) => /^\d+$/.test(c));
        segments.push(allDigits ? 'x'.repeat(column[0].length) : '*'.repeat(column[0].length));
      }
      return segments.join('-');
    }

    function matchPatternLocal(pattern, value) {
      if (window.PN_MAPPINGS_API?.matchPattern) {
        return window.PN_MAPPINGS_API.matchPattern(pattern, value);
      }
      const escaped = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
      const regex = escaped
        .replace(/x/gi, '\\d')
        .replace(/\*/g, '.')
        .replace(/\+/g, '.+');
      return new RegExp(`^${regex}$`, 'i').test(value);
    }

    function generatePatternSuggestions(rawList, options = {}) {
      const stripSpecial = options.stripSpecial === true;
      const preferPlus = options.preferPlus !== false;
      const values = rawList.map((val) => normalizeSeed(val, stripSpecial)).filter(Boolean);
      const suggestions = [];
      const positional = buildPositionalPattern(values);
      if (positional) suggestions.push(positional);
      if (preferPlus) {
        const prefix = buildPrefixPattern(values);
        if (prefix) suggestions.push(prefix);
        const suffix = buildSuffixPattern(values);
        if (suffix) suggestions.push(suffix);
      }
      const segmented = buildSegmentPattern(values);
      if (segmented) suggestions.push(segmented);
      const unique = Array.from(new Set(suggestions));
      return unique.map((pattern) => {
        const matched = values.filter((v) => matchPatternLocal(pattern, v));
        return {
          pattern,
          count: matched.length,
          total: values.length,
          examples: matched.slice(0, 3),
          confidence: Math.round((matched.length / values.length) * 100)
        };
      }).sort((a, b) => {
        if (b.count !== a.count) return b.count - a.count;
        return b.pattern.length - a.pattern.length;
      });
    }

    function renderPatternSuggestions(list) {
      if (!patternSuggestions) return;
      if (!list.length) {
        patternSuggestions.innerHTML = '<div class="pattern-suggestion"><span>Brak propozycji. Sprawdź listę PN.</span></div>';
        return;
      }
      patternSuggestions.innerHTML = list.map((item) => `
        <div class="pattern-suggestion">
          <div>
            <strong>${item.pattern}</strong>
            <span class="pattern-badge ${item.confidence >= 80 ? 'is-high' : item.confidence >= 50 ? 'is-mid' : 'is-low'}">${item.confidence}%</span>
            <small> • ${item.count}/${item.total}</small>
            ${item.examples.length ? `<div><small>Przykład: ${item.examples.join(', ')}</small></div>` : ''}
          </div>
          <button type="button" data-pattern="${item.pattern}">Użyj</button>
        </div>
      `).join('');
    }

    function refreshVendorOptions() {
      if (!patternVendorSelect || !window.PN_MAPPINGS_API?.get) return;
      const data = window.PN_MAPPINGS_API.get();
      const vendors = new Set();
      const exact = data?.exact || {};
      Object.values(exact).forEach((val) => {
        if (val) vendors.add(String(val).trim());
      });
      const patterns = Array.isArray(data?.patterns) ? data.patterns : [];
      patterns.forEach((p) => {
        if (p?.vendor) vendors.add(String(p.vendor).trim());
      });
      const sorted = Array.from(vendors).filter(Boolean).sort((a, b) => a.localeCompare(b));
      const current = patternVendorSelect.value;
      patternVendorSelect.innerHTML = `
        <option value="">Wybierz producenta</option>
        <option value="__custom__">Wpisz własnego…</option>
        ${sorted.map((v) => `<option value="${v}">${v}</option>`).join('')}
      `;
      patternVendorSelect.value = sorted.includes(current) ? current : (current === '__custom__' ? current : '');
    }

    function showToast(message, variant, durationMs) {
      if (!toastStack) return;
      const maxToasts = 6;
      while (toastStack.children.length >= maxToasts) {
        toastStack.firstElementChild?.remove();
      }
      const toast = document.createElement('div');
      toast.className = 'mapping-toast';
      if (variant === 'warn') toast.classList.add('is-warn');
      if (variant === 'info') toast.classList.add('is-info');
      if (variant === 'ok') toast.classList.add('is-ok');
      const suffix = ` (${Math.round(Number.isFinite(durationMs) ? durationMs : 0)} ms)`;
      toast.textContent = `${message || ''}${suffix}`;
      toastStack.append(toast);
      requestAnimationFrame(() => {
        toast.classList.add('is-visible');
      });
      setTimeout(() => {
        toast.classList.remove('is-visible');
        setTimeout(() => toast.remove(), 200);
      }, 8000);
    }

    function logAdminAction(action, meta = {}) {
      if (!window.PN_MAPPINGS_API?.log) return;
      window.PN_MAPPINGS_API.log('backup', { action, ...meta });
    }

    async function downloadBackup() {
      try {
        const t0 = performance.now();
        const resp = await window.PN_MAPPINGS_API.request('/backup', { method: 'GET' });
        if (!resp.ok) throw new Error('Backup failed');
        const data = await resp.json();
        const t1 = performance.now();
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const now = new Date();
        const fileStamp = now.toISOString().slice(0, 19).replace(/[:T]/g, '-');
        const link = document.createElement('a');
        link.href = url;
        link.download = `pn-mappings-backup-${fileStamp}.json`;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
        const displayStamp = new Date().toLocaleString('pl-PL');
        localStorage.setItem(ADMIN_LAST_BACKUP_KEY, displayStamp);
        if (lastBackupValue) lastBackupValue.textContent = displayStamp;
        showToast('Backup zapisany do pliku.', 'ok', t1 - t0);
        fetchLogs();
      } catch (error) {
        showToast('Nie udało się pobrać backupu z serwera.', 'warn');
      }
    }

    async function downloadFullBackup() {
      try {
        const t0 = performance.now();
        const resp = await window.PN_MAPPINGS_API.request('/backup/full', { method: 'GET' });
        if (!resp.ok) throw new Error('Full backup failed');
        const data = await resp.json();
        const t1 = performance.now();
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const now = new Date();
        const fileStamp = now.toISOString().slice(0, 19).replace(/[:T]/g, '-');
        const link = document.createElement('a');
        link.href = url;
        link.download = `pn-full-backup-${fileStamp}.json`;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
        const displayStamp = new Date().toLocaleString('pl-PL');
        localStorage.setItem(ADMIN_LAST_BACKUP_KEY, displayStamp);
        if (lastBackupValue) lastBackupValue.textContent = displayStamp;
        showToast('Pełny backup zapisany do pliku.', 'ok', t1 - t0);
        fetchLogs();
      } catch (error) {
        showToast('Nie udało się pobrać pełnego backupu.', 'warn');
      }
    }

    function restoreBackupFile(file) {
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const parsed = JSON.parse(reader.result);
          const normalized = window.PN_MAPPINGS_API.normalizeData(parsed);
          window.PN_MAPPINGS_API.set(normalized);
          updateStats(normalized);
          const stamp = new Date().toLocaleString('pl-PL');
          localStorage.setItem(ADMIN_LAST_SYNC_KEY, stamp);
          if (lastSyncValue) lastSyncValue.textContent = stamp;
          showToast('Przywrócono backup z pliku.', 'ok');
          logAdminAction('restore', { source: 'file' });
          fetchLogs();
        } catch (error) {
          showToast('Nie udało się odczytać pliku backupu.', 'warn');
        }
      };
      reader.readAsText(file);
    }

    downloadBackupBtn.addEventListener('click', () => {
      downloadBackup();
    });
    if (downloadFullBackupBtn) {
      downloadFullBackupBtn.addEventListener('click', () => {
        downloadFullBackup();
      });
    }

    async function fetchLogsBackupStatus() {
      if (!logsBackupStatus || !logsBackupTs) return;
      logsBackupStatus.textContent = 'Sprawdzam…';
      logsBackupStatus.classList.remove('is-ok', 'is-warn');
      try {
        const [logsResp, backupResp] = await Promise.all([
          window.PN_MAPPINGS_API.request('/logs?limit=20&offset=0', { method: 'GET' }),
          window.PN_MAPPINGS_API.request('/logs/backup', { method: 'GET' })
        ]);
        if (!logsResp.ok || !backupResp.ok) {
          const t1 = logsResp.ok ? '' : await logsResp.text().catch(() => '');
          const t2 = backupResp.ok ? '' : await backupResp.text().catch(() => '');
          throw new Error(`HTTP ${logsResp.status}${t1 ? `: ${t1}` : ''} / ${backupResp.status}${t2 ? `: ${t2}` : ''}`);
        }
        const logsData = await logsResp.json();
        const backupData = await backupResp.json();
        const recentLogs = Array.isArray(logsData.logs) ? logsData.logs : [];
        const ignoredTypes = new Set(['backup-logs', 'restore-logs']);
        const latestNonBackup = recentLogs.find((entry) => entry && !ignoredTypes.has(entry.type || ''))?.ts || '';
        const backupLogs = Array.isArray(backupData.logs) ? backupData.logs : [];
        logsBackupCache = backupData;
        const backupLatest = backupLogs.length ? backupLogs[backupLogs.length - 1].ts : '';
        const same = backupLatest && latestNonBackup
          ? Date.parse(backupLatest) >= Date.parse(latestNonBackup)
          : backupLogs.length === 0;
        logsBackupStatus.textContent = same ? 'Backup aktualny' : 'Backup nieaktualny';
        logsBackupStatus.classList.toggle('is-ok', same);
        logsBackupStatus.classList.toggle('is-warn', !same);
        logsBackupTs.textContent = backupData.ts || (backupLatest ? new Date(backupLatest).toLocaleString('pl-PL') : 'brak');
      } catch (error) {
        logsBackupStatus.textContent = 'Błąd';
        logsBackupStatus.classList.remove('is-ok');
        logsBackupStatus.classList.add('is-warn');
      }
    }

    if (logsBackupRefreshBtn) {
      logsBackupRefreshBtn.addEventListener('click', async () => {
        const t0 = performance.now();
        try {
          const resp = await window.PN_MAPPINGS_API.request('/logs/backup/update', { method: 'POST' });
          if (!resp.ok) {
            const text = await resp.text().catch(() => '');
            throw new Error(`HTTP ${resp.status}${text ? `: ${text}` : ''}`);
          }
          await fetchLogsBackupStatus();
          showToast('Backup logów odświeżony.', 'ok', performance.now() - t0);
        } catch (error) {
          showToast(`Błąd backupu logów: ${error.message || 'unknown'}`, 'warn');
        }
      });
    }

    if (logsBackupRestoreBtn) {
      logsBackupRestoreBtn.addEventListener('click', async () => {
        const t0 = performance.now();
        try {
          if (!logsBackupCache) await fetchLogsBackupStatus();
          const backupLogs = Array.isArray(logsBackupCache?.logs) ? logsBackupCache.logs : [];
          if (!backupLogs.length) {
            showToast('Brak backupu logów do przywrócenia.', 'warn');
            return;
          }
          const resp = await window.PN_MAPPINGS_API.request('/logs/restore', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ logs: backupLogs })
          });
          if (!resp.ok) {
            const text = await resp.text().catch(() => '');
            throw new Error(`HTTP ${resp.status}${text ? `: ${text}` : ''}`);
          }
          await fetchLogs();
          await fetchLogsBackupStatus();
          showToast('Logi przywrócone z backupu.', 'ok', performance.now() - t0);
        } catch (error) {
          showToast(`Błąd przywracania logów: ${error.message || 'unknown'}`, 'warn');
        }
      });
    }
    if (migrateLogsBtn) {
      migrateLogsBtn.addEventListener('click', () => {
        openMigrateLogsModal('full');
      });
    }
    if (dedupLogsBtn) {
      dedupLogsBtn.addEventListener('click', () => {
        openMigrateLogsModal('dedup');
      });
    }

    if (patternGenerateBtn) {
      patternGenerateBtn.addEventListener('click', () => {
        const raw = patternSeedInput?.value || '';
        const list = raw.split(/\r?\n|,|;/).map((item) => item.trim()).filter(Boolean);
        const suggestions = generatePatternSuggestions(list, {
          stripSpecial: patternStripSpecial?.checked,
          preferPlus: patternPreferPlus?.checked
        });
        renderPatternSuggestions(suggestions);
      });
    }

    if (patternVendorSelect) {
      patternVendorSelect.addEventListener('change', () => {
        const val = patternVendorSelect.value;
        if (val && val !== '__custom__') {
          patternVendor.value = val;
          patternVendor.focus();
        } else if (val === '__custom__') {
          patternVendor.value = '';
          patternVendor.focus();
        }
      });
    }

    if (patternSuggestions) {
      patternSuggestions.addEventListener('click', (event) => {
        const btn = event.target.closest('button');
        if (!btn) return;
        const pattern = btn.getAttribute('data-pattern');
        if (patternResult) patternResult.value = pattern || '';
        patternVendor?.focus();
      });
    }

    if (patternApplyBtn) {
      patternApplyBtn.addEventListener('click', () => {
        const rawPattern = patternResult?.value || '';
        const vendor = patternVendor?.value || '';
        if (!rawPattern || !vendor) {
          showToast('Uzupełnij wzorzec i producenta.', 'warn');
          return;
        }
        if (!window.PN_MAPPINGS_API?.get || !window.PN_MAPPINGS_API?.set) return;
        const data = window.PN_MAPPINGS_API.get();
        const hasPattern = /[xX*+]/.test(rawPattern);
        if (hasPattern) {
          const normalized = window.PN_MAPPINGS_API.normalizePattern(rawPattern);
          const exists = (data.patterns || []).some((p) => window.PN_MAPPINGS_API.normalizePattern(p.pattern) === normalized);
          if (!exists) {
            data.patterns = Array.isArray(data.patterns) ? data.patterns : [];
            data.patterns.push({ pattern: normalized, vendor: vendor.trim() });
            window.PN_MAPPINGS_API.set(data);
            window.PN_MAPPINGS_API?.log?.('mapping', { action: 'creator-pattern', pattern: normalized, vendor: vendor.trim() });
            showToast('Dodano wzorzec z kreatora.', 'ok');
            refreshVendorOptions();
          } else {
            showToast('Taki wzorzec już istnieje.', 'warn');
          }
        } else {
          const key = window.PN_MAPPINGS_API.normalize(rawPattern);
          data.exact = data.exact || {};
          data.exact[key] = vendor.trim();
          window.PN_MAPPINGS_API.set(data);
          window.PN_MAPPINGS_API?.log?.('mapping', { action: 'creator-exact', key, vendor: vendor.trim() });
          showToast('Dodano PN exact z kreatora.', 'ok');
          refreshVendorOptions();
        }
        updateStats(window.PN_MAPPINGS_API.get());
      });
    }
    restoreBackupBtn.addEventListener('click', () => {
      backupFileInput.click();
    });
    backupFileInput.addEventListener('change', (event) => {
      const file = event.target.files?.[0];
      if (file) restoreBackupFile(file);
      backupFileInput.value = '';
    });

    if (window.PN_MAPPINGS_API?.load) {
      window.PN_MAPPINGS_API.load()
        .then((data) => {
          updateStats(data);
          const stamp = new Date().toLocaleString('pl-PL');
          localStorage.setItem(ADMIN_LAST_SYNC_KEY, stamp);
          if (lastSyncValue) lastSyncValue.textContent = stamp;
          fetchLogs();
          fetchReports();
          resolveCurrentAppVersion();
          fetchLogsBackupStatus();
          refreshVendorOptions();
        })
        .catch(() => {
          showToast('Nie udało się pobrać mapowań z serwera.', 'warn');
          updateStats(window.PN_MAPPINGS_API.get());
        });
    }

    function updateStats(data) {
      const exact = data?.exact || {};
      const patterns = Array.isArray(data?.patterns) ? data.patterns : [];
      const exactCount = Object.keys(exact).length;
      const patternCount = patterns.length;
      if (exactCountEl) exactCountEl.textContent = exactCount;
      if (patternCountEl) patternCountEl.textContent = patternCount;
      if (totalCountEl) totalCountEl.textContent = exactCount + patternCount;
    }

    const lastBackup = localStorage.getItem(ADMIN_LAST_BACKUP_KEY);
    if (lastBackupValue) lastBackupValue.textContent = lastBackup || 'brak';
    const lastSync = localStorage.getItem(ADMIN_LAST_SYNC_KEY);
    if (lastSyncValue) lastSyncValue.textContent = lastSync || '—';

    async function fetchLogs({ notifySuccess = false } = {}) {
      if (!adminLogList) return;
      try {
        const t0 = performance.now();
        const typeFilter = logTypeFilter?.value || 'all';
        const query = (logQuery?.value || '').trim();
        const pageSize = Number(logPageSize?.value) || 20;
        const offset = Math.max(0, (logPage - 1) * pageSize);
        const params = new URLSearchParams();
        params.set('limit', String(pageSize));
        params.set('offset', String(offset));
        const compositeBackup = typeFilter === 'backup-all' || typeFilter === 'backup';
        if (typeFilter !== 'all' && !compositeBackup) params.set('type', typeFilter);
        if (query) params.set('query', query);
        const resp = await window.PN_MAPPINGS_API.request(`/logs?${params.toString()}`, { method: 'GET' });
        if (!resp.ok) {
          const text = await resp.text().catch(() => '');
          throw new Error(`HTTP ${resp.status}${text ? `: ${text}` : ''}`);
        }
        const data = await resp.json();
        const t1 = performance.now();
        logsCache = Array.isArray(data.logs) ? data.logs : [];
        totalLogs = Number.isFinite(data.total) ? data.total : null;
        if (compositeBackup) {
          const backupTypes = new Set(['backup', 'backup-full', 'backup-logs', 'restore-logs']);
          logsCache = logsCache.filter((entry) => backupTypes.has(entry.type));
          totalLogs = logsCache.length;
        }
        if (typeFilter === 'mapping-report') {
          logsCache = logsCache.filter((entry) => isReportLike(entry));
          totalLogs = logsCache.length;
        }
        renderLogs();
        if (notifySuccess) {
          showToast('Logi odświeżone.', 'ok', t1 - t0);
        }
      } catch (error) {
        adminLogList.textContent = 'Nie udało się pobrać historii.';
        const message = error?.message ? `Błąd pobierania logów: ${error.message}` : 'Błąd pobierania logów z workera.';
        showToast(message, 'warn');
      }
    }

    async function fetchReportKindsForReports(entries) {
      const ids = entries
        .map((entry) => buildReportId(entry))
        .filter(Boolean)
        .filter((id) => !reportKindCache.has(id));
      if (!ids.length) return;
      await Promise.all(ids.map((id) => fetchReportKind(id)));
    }

    async function fetchReports() {
      try {
        const resp = await window.PN_MAPPINGS_API.request('/logs?limit=200&offset=0', { method: 'GET' });
        if (!resp.ok) {
          const text = await resp.text().catch(() => '');
          throw new Error(`HTTP ${resp.status}${text ? `: ${text}` : ''}`);
        }
        const data = await resp.json();
        const rawLogs = Array.isArray(data.logs) ? data.logs : [];
        reportsCache = rawLogs.filter((entry) => isReportLike(entry));
        await fetchReportKindsForReports(reportsCache);
        scheduleRenderReports();
      } catch (error) {
        // keep existing report list on failure
      }
    }

    function renderLogs() {
      if (!adminLogList) return;
      const pageSize = Number(logPageSize?.value) || 20;
      const totalPages = Math.max(1, Math.ceil((totalLogs || logsCache.length) / pageSize));
      if (logPage > totalPages) logPage = totalPages;
      const pageItems = logsCache;
      if (logCount) {
        const countValue = Number.isFinite(totalLogs) ? totalLogs : logsCache.length;
        logCount.textContent = String(countValue);
        logCount.classList.toggle('is-bad', countValue > 0);
      }
      if (!pageItems.length) {
        adminLogList.textContent = 'Brak danych.';
      } else {
        adminLogList.innerHTML = pageItems.map((entry) => {
          const type = entry.type || 'unknown';
          const ip = entry.ip || 'unknown';
          const ts = entry.ts ? new Date(entry.ts).toLocaleString('pl-PL') : '—';
          const ua = entry.ua || 'unknown';
          const fp = entry.clientFp || 'unknown';
          const geo = entry.geo || {};
          const place = [geo.city, geo.region, geo.country].filter(Boolean).join(', ') || 'unknown';
          const asn = geo.asn ? `AS${geo.asn}` : 'unknown';
          const ray = entry.ray || '—';
          const hasMeta = entry.meta && Object.keys(entry.meta).length > 0;
          const entryIndex = logsCache.indexOf(entry);
          const metaId = `meta-${entryIndex}`;
          const rawMeta = hasMeta ? escapeHtml(JSON.stringify(entry.meta)) : '';
          return `
            <div class="admin-log-item">
              <div class="log-main">
                <strong>${type}</strong>
                <div class="log-actions">
                  <span>${ts}</span>
                  ${hasMeta ? `<button type="button" class="log-pretty" data-log-index="${entryIndex}">Prettify</button>` : ''}
                </div>
              </div>
              <div class="log-sub">
                <span>IP: ${ip}</span>
                <span>FP: ${fp}</span>
                <span>${place}</span>
                <span>${asn}</span>
                <span>Ray: ${ray}</span>
              </div>
              ${hasMeta ? `
                <div class="log-meta">
                  <div class="log-meta-raw">${rawMeta}</div>
                  <pre class="log-pretty-content" id="${metaId}" hidden></pre>
                </div>
              ` : ''}
              <div class="log-ua">${ua}</div>
            </div>
          `;
        }).join('');
      }
      if (logPageInfo) {
        logPageInfo.textContent = `Strona ${logPage} / ${totalPages}`;
      }
      if (logPrevBtn) logPrevBtn.disabled = logPage <= 1;
      if (logNextBtn) logNextBtn.disabled = logPage >= totalPages;
      // reporty są ładowane osobno
    }

    function escapeHtml(value) {
      return String(value || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function formatPreviewValue(value) {
      if (value === null || value === undefined) return '';
      if (typeof value === 'string') return escapeHtml(value);
      try {
        return escapeHtml(JSON.stringify(value));
      } catch (error) {
        return escapeHtml(String(value));
      }
    }

    function isReportLike(entry) {
      if (!entry) return false;
      const type = entry.type || '';
      if (type === 'backup-logs' || type === 'restore-logs') return false;
      if (type === 'mapping-report') return true;
      const meta = entry.meta || {};
      const report = meta.report || {};
      return !!(
        meta.reportId ||
        report.reportId ||
        meta.reason ||
        meta.query ||
        meta.suggestedVendor ||
        meta.detail ||
        report.reason ||
        report.query ||
        report.suggestedVendor ||
        report.detail ||
        meta.kind ||
        report.kind
      );
    }

    function formatMetaPretty(entry) {
      const meta = entry.meta || {};
      const lines = [];
      const usedKeys = new Set();
      if (entry.type) lines.push(`Typ: ${entry.type}`);
      if (meta.action) {
        lines.push(`Akcja: ${meta.action}`);
        usedKeys.add('action');
      }
      if (entry.type === 'mapping-report') {
        const report = meta.report || {
          query: meta.query,
          suggestedVendor: meta.suggestedVendor,
          source: meta.source,
          detail: meta.detail,
          reason: meta.reason
        };
        if (report && (report.query || report.suggestedVendor || report.source || report.detail || report.reason)) {
          if (report.query) lines.push(`Zgłoszenie PN: ${report.query}`);
          if (report.suggestedVendor) lines.push(`Zgłoszony producent: ${report.suggestedVendor}`);
          if (report.reason) lines.push(`Powód: ${report.reason}`);
          usedKeys.add('report.query');
          usedKeys.add('report.suggestedVendor');
          usedKeys.add('report.reason');
        }
        if (meta.mapping) {
          const m = meta.mapping || {};
          if (m.key) lines.push(`Mapa -> PN/wzorzec: ${m.key}`);
          if (m.vendor) lines.push(`Mapa -> producent: ${m.vendor}`);
          if (m.type) lines.push(`Typ wpisu: ${m.type}`);
          if (m.note) lines.push(`Uwagi admina: ${m.note}`);
          usedKeys.add('mapping.key');
          usedKeys.add('mapping.vendor');
          usedKeys.add('mapping.type');
          usedKeys.add('mapping.note');
        }
        if (report && (report.source || report.detail)) {
          lines.push('');
          const parts = [];
          if (report.source) parts.push(`Źródło: ${report.source}`);
          if (report.detail) parts.push(`Wzorzec: ${report.detail}`);
          lines.push(`// ${parts.join(' · ')}`);
          usedKeys.add('report.source');
          usedKeys.add('report.detail');
        }
        const flatAll = flattenMeta(meta);
        const allKeys = Object.keys(flatAll).filter((key) => !usedKeys.has(key));
        if (allKeys.length) {
          lines.push('');
          lines.push('--- Pozostałe pola ---');
          allKeys.sort().forEach((key) => {
            lines.push(`${key}: ${flatAll[key]}`);
          });
        }
      } else {
        const flat = flattenMeta(meta);
        const keys = Object.keys(flat);
        if (keys.length) {
          keys.sort().forEach((key) => {
            lines.push(`${key}: ${flat[key]}`);
          });
        }
      }
      if (!lines.length) return JSON.stringify(meta, null, 2);
      return lines.join('\n');
    }

    function flattenMeta(obj, prefix = '', out = {}) {
      if (!obj || typeof obj !== 'object') return out;
      for (const [key, value] of Object.entries(obj)) {
        const nextKey = prefix ? `${prefix}.${key}` : key;
        if (value && typeof value === 'object' && !Array.isArray(value)) {
          flattenMeta(value, nextKey, out);
        } else {
          out[nextKey] = Array.isArray(value) ? value.join(', ') : String(value);
        }
      }
      return out;
    }

    const DISMISSED_REPORTS_KEY = 'adminDismissedReports';
    let dismissedReports = new Set();
    try {
      const stored = JSON.parse(localStorage.getItem(DISMISSED_REPORTS_KEY) || '[]');
      dismissedReports = new Set(stored);
    } catch (error) {
      dismissedReports = new Set();
    }

    function buildReportKeyFromMeta(meta = {}) {
      if (meta.reportId) return meta.reportId;
      const parts = [
        meta.query || '',
        meta.suggestedVendor || '',
        meta.source || '',
        meta.detail || '',
        meta.reason || ''
      ];
      const joined = parts.join('|');
      if (joined.replace(/\|/g, '').trim() === '') return '';
      return joined;
    }

    const reportKindCache = new Map();
    const reportKindLoading = new Set();

    function getReportKindOverride(reportId) {
      if (!reportId) return '';
      return reportKindCache.get(reportId) || '';
    }

    async function fetchReportKind(reportId) {
      if (!reportId || reportKindCache.has(reportId) || reportKindLoading.has(reportId)) return;
      if (!window.PN_MAPPINGS_API?.request) return;
      reportKindLoading.add(reportId);
      try {
        const resp = await window.PN_MAPPINGS_API.request(`/report-kind?id=${encodeURIComponent(reportId)}`, { method: 'GET' });
        const data = await resp.json().catch(() => ({}));
        const kind = typeof data.kind === 'string' ? data.kind : '';
        reportKindCache.set(reportId, kind);
      } catch (error) {
        reportKindCache.set(reportId, '');
      } finally {
        reportKindLoading.delete(reportId);
      }
    }

    async function setReportKindOverride(reportId, kind) {
      if (!reportId) return;
      reportKindCache.set(reportId, kind || '');
      if (!window.PN_MAPPINGS_API?.request) return;
      try {
        if (kind) {
          await window.PN_MAPPINGS_API.request(`/report-kind?id=${encodeURIComponent(reportId)}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ kind })
          });
        } else {
          await window.PN_MAPPINGS_API.request(`/report-kind?id=${encodeURIComponent(reportId)}`, { method: 'DELETE' });
        }
      } catch (error) {
        // keep cache
      }
    }

    function getReportMeta(entry) {
      if (!entry) return {};
      const meta = entry.meta || {};
      return meta.report || meta;
    }

    function getReportKind(entry) {
      const meta = getReportMeta(entry);
      const reportId = buildReportId(entry);
      const override = getReportKindOverride(reportId);
      if (override) return override;
      const inferredUi = !meta.kind && !meta.query && !meta.suggestedVendor && meta.reason;
      return meta.kind || (inferredUi ? 'ui' : 'mapping');
    }

    function buildReportKey(entry) {
      const meta = entry.meta || {};
      if (meta.reportId) return meta.reportId;
      if (meta.report && meta.report.reportId) return meta.report.reportId;
      const report = meta.report || meta;
      const metaKey = buildReportKeyFromMeta(report);
      if (metaKey) return metaKey;
      return `${entry.ts || ''}|${entry.ray || ''}`;
    }

    function persistDismissedReports() {
      localStorage.setItem(DISMISSED_REPORTS_KEY, JSON.stringify(Array.from(dismissedReports)));
    }

    const REPORT_STATUS_KEY = 'adminReportStatus';

    function loadReportStatus() {
      try {
        return JSON.parse(localStorage.getItem(REPORT_STATUS_KEY) || '{}');
      } catch (error) {
        return {};
      }
    }

    function setReportStatus(reportId, status) {
      if (!reportId) return;
      const map = loadReportStatus();
      if (status) {
        map[reportId] = status;
      } else {
        delete map[reportId];
      }
      localStorage.setItem(REPORT_STATUS_KEY, JSON.stringify(map));
    }

    function getReportStatus(reportId) {
      if (!reportId) return '';
      const map = loadReportStatus();
      return map[reportId] || '';
    }

    let renderReportsScheduled = false;
    function scheduleRenderReports() {
      if (renderReportsScheduled) return;
      renderReportsScheduled = true;
      requestAnimationFrame(() => {
        renderReportsScheduled = false;
        renderReports();
      });
    }

    function renderReports() {
      if (!reportList) return;
      const allReports = reportsCache.filter((entry) => entry.type === 'mapping-report');
      const baseReports = allReports.filter((entry) => !entry?.meta?.action);
      const reportById = new Map();
      baseReports.forEach((entry) => {
        const reportId = buildReportId(entry);
        if (!reportId) return;
        const prev = reportById.get(reportId);
        if (!prev) {
          reportById.set(reportId, entry);
          return;
        }
        const prevTs = prev.ts ? Date.parse(prev.ts) : 0;
        const nextTs = entry.ts ? Date.parse(entry.ts) : 0;
        if (nextTs >= prevTs) {
          reportById.set(reportId, entry);
        }
      });
      const reports = Array.from(reportById.values());
      const mappingReports = [];
      const uiReports = [];
      reports.forEach((entry) => {
        const kind = getReportKind(entry);
        if (kind === 'ui') uiReports.push(entry);
        else mappingReports.push(entry);
      });
      const resolvedKeys = new Set();
      reportsCache.forEach((entry) => {
        if (entry.type !== 'mapping-report') return;
        const action = entry?.meta?.action;
        if (!action || action === 'on-hold' || action === 'retype') return;
        const key = buildReportKey(entry);
        if (key) resolvedKeys.add(key);
      });
      const visibleReports = reports.filter((entry) => {
        const key = buildReportKey(entry);
        const status = getReportStatus(buildReportId(entry));
        if (status === 'resolved' || status === 'dismissed') return false;
        if (dismissedReports.has(key)) return false;
        if (resolvedKeys.has(key)) return false;
        return true;
      });
      const visibleMapping = visibleReports.filter((entry) => getReportKind(entry) !== 'ui');
      const visibleUi = visibleReports.filter((entry) => getReportKind(entry) === 'ui');
      if (reportCount) {
        reportCount.textContent = String(visibleReports.length);
        reportCount.classList.toggle('is-bad', visibleReports.length > 0);
      }
      if (!visibleReports.length) {
        reportList.textContent = 'Brak zgłoszeń.';
        return;
      }
      const sectionTemplate = (title, entries) => {
        if (!entries.length) return '';
        return `
          <div class="report-section">
            <div class="report-section-title">${title}</div>
            ${entries.map((entry, index) => renderReportItem(entry, index)).join('')}
          </div>
        `;
      };

      const filterValue = reportFilter?.value || 'all';
      let sections = [];
      if (filterValue === 'mapping') {
        sections = [sectionTemplate('Zgłoszenia mapowań', visibleMapping)];
      } else if (filterValue === 'ui') {
        sections = [sectionTemplate('Błędy działania strony', visibleUi)];
      } else {
        sections = [
          sectionTemplate('Zgłoszenia mapowań', visibleMapping),
          sectionTemplate('Błędy działania strony', visibleUi)
        ];
      }

      reportList.innerHTML = sections.join('');
      hydrateAdminNotes();
      // overrides są ładowane w batchu przy fetchReports

      if (!reportList.innerHTML.trim()) {
        reportList.textContent = 'Brak zgłoszeń.';
      }
    }

    function renderReportItem(entry, index) {
      const meta = getReportMeta(entry);
      const query = escapeHtml(meta.query || '');
      const suggestedVendor = escapeHtml(meta.suggestedVendor || '');
      const source = escapeHtml(meta.source || '');
      const detail = escapeHtml(meta.detail || '');
      const reason = escapeHtml(meta.reason || '');
      const ts = entry.ts ? new Date(entry.ts).toLocaleString('pl-PL') : '—';
      const reportKey = escapeHtml(buildReportKey(entry));
      const kind = getReportKind(entry);
      const kindLabel = kind === 'ui' ? 'Błąd działania strony' : 'Błąd mapowania';
      const reportId = buildReportId(entry);
      const storedNote = getAdminNote(reportId);
      const reportStatus = getReportStatus(reportId);
      if (kind === 'ui') {
        return `
          <div class="report-item report-${kind} ${reportStatus === 'on-hold' ? 'is-on-hold' : ''}" data-report-index="${index}" data-report-key="${reportKey}" data-report-query="${query}" data-report-vendor="${suggestedVendor}" data-report-source="${source}" data-report-detail="${detail}" data-report-reason="${reason}" data-report-kind="${kind}" data-report-id="${reportId}">
            <div class="report-header">
              <strong>ID: ${reportId}</strong>
              <div class="report-header-meta">
                <span class="report-ts">${ts}</span>
                <div class="report-meta-row">
                  <span class="report-kind">${kindLabel}</span>
                  <button type="button" class="report-kind-toggle" aria-label="Zmień typ zgłoszenia">↔</button>
                </div>
              </div>
            </div>
            ${reason ? `<div class="report-reason"><span class="report-reason-label">Uwagi:</span> <strong>${reason}</strong></div>` : ''}
            <div class="report-form">
              <textarea class="report-note" rows="2" placeholder="Notatki admina (opcjonalne)">${storedNote}</textarea>
              <div class="report-actions">
                <button type="button" class="report-resolve">Resolved</button>
                <button type="button" class="report-hold">On hold</button>
                <button type="button" class="report-dismiss">Usuń zgłoszenie</button>
              </div>
              ${(source || detail) ? `<div class="report-extra">// ${source ? `Źródło: ${source}` : ''}${detail ? ` · Wzorzec: ${detail}` : ''}</div>` : ''}
            </div>
          </div>
        `;
      }
      return `
          <div class="report-item report-${kind} ${reportStatus === 'on-hold' ? 'is-on-hold' : ''}" data-report-index="${index}" data-report-key="${reportKey}" data-report-query="${query}" data-report-vendor="${suggestedVendor}" data-report-source="${source}" data-report-detail="${detail}" data-report-reason="${reason}" data-report-kind="${kind}" data-report-id="${reportId}">
            <div class="report-header">
              <strong>${query || '—'}</strong>
              <div class="report-header-meta">
                <span class="report-ts">${ts}</span>
                <div class="report-meta-row">
                  <span class="report-kind">${kindLabel}</span>
                  <button type="button" class="report-kind-toggle" aria-label="Zmień typ zgłoszenia">↔</button>
                  <span class="report-id">ID: ${reportId}</span>
                </div>
              </div>
            </div>
            <div class="report-meta">
              <span>Sugestia: <strong>${suggestedVendor || '—'}</strong></span>
              <span>Źródło: ${source || '—'}</span>
              ${detail ? `<span>Wzorzec: ${detail}</span>` : ''}
            </div>
            ${reason ? `<div class="report-reason"><span class="report-reason-label">Uwagi:</span> <strong>${reason}</strong></div>` : ''}
            <div class="report-form">
              <input type="text" class="report-key" placeholder="PN lub wzorzec" value="${query}">
              <input type="text" class="report-vendor" placeholder="Producent (np. Dell)" value="${suggestedVendor}">
              <div class="report-mode">
                <label>Typ wpisu</label>
                <select class="report-type">
                  <option value="auto" selected>Auto (PN lub wzorzec)</option>
                  <option value="exact">PN exact</option>
                  <option value="pattern">Wzorzec</option>
                </select>
              </div>
              <textarea class="report-note" rows="2" placeholder="Uwagi admina / powód korekty" disabled>${reason}</textarea>
              <div class="report-actions">
                <button type="button" class="report-apply">Dodaj / popraw mapowanie</button>
                <button type="button" class="report-dismiss">Usuń zgłoszenie</button>
              </div>
            </div>
          </div>
        `;
    }

    function buildReportId(entry) {
      const meta = entry.meta || {};
      if (meta.reportId) return meta.reportId;
      if (meta.report && meta.report.reportId) return meta.report.reportId;
      const report = meta.report || {
        query: meta.query,
        suggestedVendor: meta.suggestedVendor,
        source: meta.source,
        detail: meta.detail,
        reason: meta.reason
      };
      const raw = [
        entry.ts || '',
        entry.ray || '',
        report.query || '',
        report.suggestedVendor || '',
        report.source || '',
        report.detail || '',
        report.reason || ''
      ].join('|');
      let hash = 5381;
      for (let i = 0; i < raw.length; i += 1) {
        hash = ((hash << 5) + hash) + raw.charCodeAt(i);
      }
      return `R-${(hash >>> 0).toString(16).slice(0, 8)}`;
    }

    const adminNotesCache = new Map();
    const adminNotesLoading = new Set();

    function getAdminNote(reportId) {
      if (!reportId) return '';
      return adminNotesCache.get(reportId) || '';
    }

    async function fetchAdminNote(reportId) {
      if (!reportId || adminNotesCache.has(reportId) || adminNotesLoading.has(reportId)) return;
      if (!window.PN_MAPPINGS_API?.request) return;
      adminNotesLoading.add(reportId);
      try {
        const resp = await window.PN_MAPPINGS_API.request(`/notes?id=${encodeURIComponent(reportId)}`, { method: 'GET' });
        const data = await resp.json().catch(() => ({}));
        const note = typeof data.note === 'string' ? data.note : '';
        adminNotesCache.set(reportId, note);
        const field = document.querySelector(`.report-item[data-report-id="${reportId}"] .report-note`);
        if (field) field.value = note;
      } catch (error) {
        adminNotesCache.set(reportId, '');
      } finally {
        adminNotesLoading.delete(reportId);
      }
    }

    async function setAdminNote(reportId, note) {
      if (!reportId) return;
      adminNotesCache.set(reportId, note || '');
      if (!window.PN_MAPPINGS_API?.request) return;
      try {
        if (note) {
          await window.PN_MAPPINGS_API.request(`/notes?id=${encodeURIComponent(reportId)}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ note })
          });
        } else {
          await window.PN_MAPPINGS_API.request(`/notes?id=${encodeURIComponent(reportId)}`, { method: 'DELETE' });
        }
      } catch (error) {
        // ignore, cache still holds latest note
      }
    }

    function isPatternValue(value) {
      return /[x*+]/i.test(value);
    }

    function getReportMetaFromItem(item) {
      if (!item) return {};
      return {
        query: item.getAttribute('data-report-query') || '',
        suggestedVendor: item.getAttribute('data-report-vendor') || '',
        source: item.getAttribute('data-report-source') || '',
        detail: item.getAttribute('data-report-detail') || '',
        reason: item.getAttribute('data-report-reason') || '',
        kind: item.getAttribute('data-report-kind') || 'mapping',
        reportId: item.getAttribute('data-report-id') || ''
      };
    }

    function hydrateAdminNotes() {
      const noteFields = Array.from(document.querySelectorAll('.report-item .report-note'));
      noteFields.forEach((field) => {
        const reportId = field.closest('.report-item')?.getAttribute('data-report-id') || '';
        if (!reportId) return;
        if (!adminNotesCache.has(reportId)) {
          fetchAdminNote(reportId);
        }
      });
    }

    function hydrateReportKinds() {}

    function applyReportMappingFromData({ rawKey, vendor, note, typeMode }) {
      if (!rawKey || !vendor) {
        showToast('Uzupełnij PN/wzorzec i producenta.', 'warn');
        return;
      }
      const data = window.PN_MAPPINGS_API.get();
      const treatAsPattern = typeMode === 'pattern' || (typeMode === 'auto' && isPatternValue(rawKey));
      if (treatAsPattern) {
        const pattern = window.PN_MAPPINGS_API.normalizePattern(rawKey);
        data.patterns = Array.isArray(data.patterns) ? data.patterns : [];
        const existing = data.patterns.find((rule) => rule.pattern === pattern);
        if (existing) {
          existing.vendor = vendor;
        } else {
          data.patterns.push({ pattern, vendor });
        }
        window.PN_MAPPINGS_API.set(data);
        showToast(`Zapisano wzorzec: ${pattern} → ${vendor}`, 'ok');
        window.PN_MAPPINGS_API.log('mapping', { action: 'apply-report-pattern', pattern, vendor, note });
      } else {
        const key = window.PN_MAPPINGS_API.normalize(rawKey);
        data.exact = data.exact || {};
        data.exact[key] = vendor;
        window.PN_MAPPINGS_API.set(data);
        showToast(`Zapisano PN: ${key} → ${vendor}`, 'ok');
        window.PN_MAPPINGS_API.log('mapping', { action: 'apply-report-exact', key, vendor, note });
      }
      updateStats(window.PN_MAPPINGS_API.get());
    }

    function logReportAction(meta) {
      if (window.PN_MAPPINGS_API?.request) {
        window.PN_MAPPINGS_API.request('/log', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type: 'mapping-report', meta })
        }).catch(() => {
          window.PN_MAPPINGS_API?.log?.('mapping-report', meta);
        });
        return;
      }
      window.PN_MAPPINGS_API?.log?.('mapping-report', meta);
    }

    function closeReportConfirmModal() {
      if (!reportConfirmModal) return;
      reportConfirmModal.style.display = 'none';
      pendingReportApply = null;
    }

    function openReportConfirmModal(item) {
      if (!item || !reportConfirmModal) return;
      const keyInput = item.querySelector('.report-key');
      const vendorInput = item.querySelector('.report-vendor');
      const noteInput = item.querySelector('.report-note');
      const typeSelect = item.querySelector('.report-type');
      const rawKey = keyInput?.value?.trim() || '';
      const vendor = vendorInput?.value?.trim() || '';
      const reason = noteInput?.value?.trim() || '';
      const typeMode = typeSelect?.value || 'auto';
      if (reportConfirmKey) reportConfirmKey.value = rawKey;
      if (reportConfirmVendor) reportConfirmVendor.value = vendor;
      if (reportConfirmType) reportConfirmType.value = typeMode;
      if (reportConfirmNote) reportConfirmNote.value = '';
      if (reportConfirmInfo) {
        reportConfirmInfo.textContent = reason ? `Powód zgłoszenia: ${reason}` : 'Powód zgłoszenia: —';
      }
      pendingReportApply = {
        sourceReason: reason,
        reportKey: item.getAttribute('data-report-key') || '',
        reportItem: item,
        reportMeta: getReportMetaFromItem(item)
      };
      reportConfirmModal.style.display = 'flex';
      reportConfirmKey?.focus();
    }

    function closeReportDismissModal() {
      if (!reportDismissModal) return;
      reportDismissModal.style.display = 'none';
      pendingReportDismiss = null;
    }

    function openReportDismissModal(item) {
      if (!item || !reportDismissModal) return;
      const key = item.getAttribute('data-report-key') || '';
      const title = item.querySelector('.report-header strong')?.textContent || 'zgłoszenie';
      const reportId = item.getAttribute('data-report-id') || '';
      if (reportDismissMessage) {
        const idSuffix = reportId ? ` (${reportId})` : '';
        reportDismissMessage.textContent = `Czy na pewno chcesz usunąć zgłoszenie: ${title}${idSuffix}?`;
      }
      const meta = getReportMetaFromItem(item);
      pendingReportDismiss = { key, item, meta };
      reportDismissModal.style.display = 'flex';
    }

    function closeReportRetypeModal() {
      if (!reportRetypeModal) return;
      reportRetypeModal.style.display = 'none';
      pendingReportRetype = null;
    }

    function openReportRetypeModal(item, nextKind) {
      if (!item || !reportRetypeModal) return;
      const title = item.querySelector('.report-header strong')?.textContent || 'zgłoszenie';
      if (reportRetypeMessage) {
        const label = nextKind === 'ui' ? 'Błąd działania strony' : 'Błąd mapowania';
        reportRetypeMessage.textContent = `Zmień typ ${title} na: ${label}?`;
      }
      pendingReportRetype = {
        reportId: item.getAttribute('data-report-id') || '',
        nextKind
      };
      reportRetypeModal.style.display = 'flex';
    }

    [logTypeFilter, logQuery, logPageSize].forEach((el) => {
      if (!el) return;
      el.addEventListener('input', () => {
        logPage = 1;
        fetchLogs();
      });
      el.addEventListener('change', () => {
        logPage = 1;
        fetchLogs();
      });
    });
    if (logRefreshBtn) {
      logRefreshBtn.addEventListener('click', () => {
        fetchLogs({ notifySuccess: true });
        fetchReports();
        fetchLogsBackupStatus();
      });
    }
    if (logPrevBtn) {
      logPrevBtn.addEventListener('click', () => {
        logPage = Math.max(1, logPage - 1);
        fetchLogs();
      });
    }
    if (logNextBtn) {
      logNextBtn.addEventListener('click', () => {
        logPage += 1;
        fetchLogs();
      });
    }
    if (reportFilter) {
      reportFilter.addEventListener('change', () => {
        renderReports();
      });
    }
    if (adminLogList) {
      adminLogList.addEventListener('click', (event) => {
        const target = event.target;
        if (!target) return;
        const prettyBtn = target.closest('.log-pretty');
        if (!prettyBtn) return;
        const idx = Number(prettyBtn.getAttribute('data-log-index'));
        if (Number.isNaN(idx)) return;
        const entry = logsCache[idx];
        const pre = document.getElementById(`meta-${idx}`);
        if (!pre || !entry?.meta) return;
        const raw = pre.closest('.log-meta')?.querySelector('.log-meta-raw');
        if (pre.hasAttribute('hidden')) {
          pre.textContent = formatMetaPretty(entry);
          pre.removeAttribute('hidden');
          if (raw) raw.setAttribute('hidden', 'hidden');
          prettyBtn.textContent = 'Ukryj';
        } else {
          pre.setAttribute('hidden', 'hidden');
          if (raw) raw.removeAttribute('hidden');
          prettyBtn.textContent = 'Prettify';
        }
      });
    }
    if (reportList) {
      reportList.addEventListener('click', (event) => {
        const target = event.target;
        if (!target) return;
        const kindToggle = target.closest('.report-kind-toggle');
        if (kindToggle) {
          const item = kindToggle.closest('.report-item');
          if (!item) return;
          const current = item.getAttribute('data-report-kind') || 'mapping';
          const next = current === 'ui' ? 'mapping' : 'ui';
          openReportRetypeModal(item, next);
          return;
        }
        const applyBtn = target.closest('.report-apply');
        if (applyBtn) {
          const item = applyBtn.closest('.report-item');
          openReportConfirmModal(item);
          return;
        }
        const resolveBtn = target.closest('.report-resolve');
        if (resolveBtn) {
          const item = resolveBtn.closest('.report-item');
          if (!item) return;
          const reportMeta = getReportMetaFromItem(item);
          reportMeta.kind = 'ui';
          const adminNote = item.querySelector('.report-note')?.value?.trim() || '';
          const reportId = item.getAttribute('data-report-id') || '';
          setAdminNote(reportId, adminNote);
          logReportAction({
            action: 'resolved',
            report: reportMeta,
            mapping: {
              key: 'nie dotyczy',
              vendor: 'nie dotyczy',
              type: 'działanie strony',
              note: adminNote || 'nie dotyczy'
            }
          });
          if (reportMeta) {
            const key = buildReportKeyFromMeta(reportMeta);
            if (key) {
              dismissedReports.add(key);
              persistDismissedReports();
            }
          }
          if (reportId) setReportStatus(reportId, 'resolved');
          item.classList.remove('is-on-hold');
          item.remove();
          showToast('Zgłoszenie oznaczone jako resolved.', 'ok');
          renderReports();
          return;
        }
        const holdBtn = target.closest('.report-hold');
        if (holdBtn) {
          const item = holdBtn.closest('.report-item');
          if (!item) return;
          const reportMeta = getReportMetaFromItem(item);
          reportMeta.kind = 'ui';
          const adminNote = item.querySelector('.report-note')?.value?.trim() || '';
          const reportId = item.getAttribute('data-report-id') || '';
          setAdminNote(reportId, adminNote);
          logReportAction({
            action: 'on-hold',
            report: reportMeta,
            mapping: {
              key: 'nie dotyczy',
              vendor: 'nie dotyczy',
              type: 'działanie strony',
              note: adminNote || 'nie dotyczy'
            }
          });
          if (reportId) setReportStatus(reportId, 'on-hold');
          item.classList.add('is-on-hold');
          showToast('Zgłoszenie oznaczone jako on hold.', 'info');
          return;
        }
        const dismissBtn = target.closest('.report-dismiss');
        if (!dismissBtn) return;
        const item = dismissBtn.closest('.report-item');
        if (!item) return;
        const reportId = item.getAttribute('data-report-id') || '';
        setAdminNote(reportId, '');
        openReportDismissModal(item);
      });
    }

    if (reportConfirmClose) {
      reportConfirmClose.addEventListener('click', closeReportConfirmModal);
    }
    if (reportConfirmCancel) {
      reportConfirmCancel.addEventListener('click', closeReportConfirmModal);
    }
    if (reportConfirmApply) {
      reportConfirmApply.addEventListener('click', () => {
        const rawKey = reportConfirmKey?.value?.trim() || '';
        const vendor = reportConfirmVendor?.value?.trim() || '';
        const note = reportConfirmNote?.value?.trim() || '';
        const typeMode = reportConfirmType?.value || 'auto';
        const uiStatus = reportConfirmStatus?.value || 'resolved';
        if (rawKey && vendor) {
          applyReportMappingFromData({ rawKey, vendor, note, typeMode });
          logReportAction({
            action: 'resolved',
            report: pendingReportApply?.reportMeta || {},
            mapping: {
              key: rawKey,
              vendor,
              type: typeMode,
              note
            }
          });
          const resolvedId = pendingReportApply?.reportItem?.getAttribute('data-report-id') || '';
          if (resolvedId) setReportStatus(resolvedId, 'resolved');
          showToast('Zgłoszenie zamknięte po zapisie mapowania.', 'ok');
        } else {
          const reportMeta = pendingReportApply?.reportMeta || {};
          reportMeta.kind = 'ui';
          logReportAction({
            action: uiStatus === 'on-hold' ? 'on-hold' : 'resolved',
            report: reportMeta,
            mapping: {
              key: 'nie dotyczy',
              vendor: 'nie dotyczy',
              type: 'działanie strony',
              note: note || 'nie dotyczy'
            }
          });
          const resolvedId = pendingReportApply?.reportItem?.getAttribute('data-report-id') || '';
          if (resolvedId) setReportStatus(resolvedId, uiStatus === 'on-hold' ? 'on-hold' : 'resolved');
          if (uiStatus === 'on-hold') {
            showToast('Zgłoszenie oznaczone jako on hold.', 'info');
          } else {
            showToast('Zgłoszenie zamknięte jako problem działania strony.', 'ok');
          }
        }
        if (uiStatus !== 'on-hold') {
          if (pendingReportApply?.reportKey) {
            dismissedReports.add(pendingReportApply.reportKey);
            persistDismissedReports();
          }
          if (pendingReportApply?.reportItem) {
            pendingReportApply.reportItem.classList.remove('is-on-hold');
            pendingReportApply.reportItem.remove();
          }
        } else if (pendingReportApply?.reportItem) {
          pendingReportApply.reportItem.classList.add('is-on-hold');
        }
        renderReports();
        closeReportConfirmModal();
      });
    }

    if (reportDismissClose) {
      reportDismissClose.addEventListener('click', closeReportDismissModal);
    }
    if (reportDismissCancel) {
      reportDismissCancel.addEventListener('click', closeReportDismissModal);
    }
    if (reportDismissApply) {
      reportDismissApply.addEventListener('click', () => {
        if (pendingReportDismiss?.key) {
          dismissedReports.add(pendingReportDismiss.key);
          persistDismissedReports();
        }
        if (pendingReportDismiss?.item) {
          pendingReportDismiss.item.remove();
        }
        const dismissedId = pendingReportDismiss?.item?.getAttribute('data-report-id') || '';
        if (dismissedId) setReportStatus(dismissedId, 'dismissed');
        logReportAction({
          action: 'dismissed',
          report: pendingReportDismiss?.meta || {}
        });
        showToast('Zgłoszenie usunięte.', 'ok');
        renderReports();
        closeReportDismissModal();
      });
    }

    if (reportRetypeClose) {
      reportRetypeClose.addEventListener('click', closeReportRetypeModal);
    }
    if (reportRetypeCancel) {
      reportRetypeCancel.addEventListener('click', closeReportRetypeModal);
    }
    if (reportRetypeApply) {
      reportRetypeApply.addEventListener('click', () => {
        if (!pendingReportRetype) return;
        const { reportId, nextKind } = pendingReportRetype;
        if (!reportId) {
          closeReportRetypeModal();
          return;
        }
        setReportKindOverride(reportId, nextKind);
        setReportStatus(reportId, '');
        const retypeItem = reportList?.querySelector(`.report-item[data-report-id="${reportId}"]`);
        retypeItem?.classList.remove('is-on-hold');
        const entry = logsCache.find((log) => buildReportId(log) === reportId);
        if (entry && entry.meta) {
          entry.meta.kind = nextKind;
        }
        logReportAction({
          action: 'retype',
          report: entry?.meta || { reportId },
          newKind: nextKind
        });
        showToast('Zmieniono typ zgłoszenia.', 'ok');
        renderReports();
        closeReportRetypeModal();
      });
    }

    function closeMigrateLogsModal() {
      if (!migrateLogsModal) return;
      migrateLogsModal.style.display = 'none';
    }

    async function resolveCurrentAppVersion() {
      const cached = localStorage.getItem('appVersion') || '';
      if (location.protocol === 'file:') {
        return cached;
      }
      try {
        const resp = await fetch(`index.html?cb=${Date.now()}`);
        if (!resp.ok) return cached;
        const html = await resp.text();
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const el = doc.getElementById('appVersion');
        const fresh = (el?.textContent || '').trim();
        if (fresh && fresh !== cached) {
          localStorage.setItem('appVersion', fresh);
          return fresh;
        }
      } catch (error) {
        // ignore and fallback to cached
      }
      return cached;
    }

    async function openMigrateLogsModal(mode = 'full') {
      if (!migrateLogsModal) return;
      migrateMode = mode;
      const currentVersion = await resolveCurrentAppVersion();
      if (!currentVersion) {
        showToast('Brak wersji aplikacji — uruchom najpierw kalkulator.', 'warn');
        return;
      }
      if (migrateLogsSummary) {
        migrateLogsSummary.textContent = 'Ładuję podgląd zmian…';
      }
      if (migrateLogsSummary) migrateLogsSummary.textContent = 'Ładuję podgląd zmian…';
      if (migrateLogsList) migrateLogsList.innerHTML = '';
      try {
        const dedup = false;
        const resp = await window.PN_MAPPINGS_API.request('/migrate-logs', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            version: currentVersion,
            dedup,
            mode,
            apply: false
          })
        });
        if (!resp.ok) {
          const text = await resp.text().catch(() => '');
          throw new Error(`HTTP ${resp.status}${text ? `: ${text}` : ''}`);
        }
        const data = await resp.json();
        const items = Array.isArray(data.items) ? data.items : [];
        const dedupItems = Array.isArray(data.dedup) ? data.dedup : [];
        const showItems = mode === 'dedup' ? dedupItems : items;
        if (!showItems.length) {
          showToast(mode === 'dedup' ? 'Brak duplikatów do scalenia.' : 'Brak wpisów do migracji.', 'info');
          return;
        }
        migrateLogsModal.style.display = 'flex';
        if (migrateLogsSummary) {
          const totalLabel = mode === 'dedup'
            ? `Duplikaty: ${dedupItems.length}.`
            : `Do migracji: ${items.length}.`;
          migrateLogsSummary.textContent = `${totalLabel} Wersja docelowa: ${currentVersion}.`;
        }
        if (migrateLogsList) {
          if (mode === 'dedup') {
            migrateLogsList.innerHTML = dedupItems.map((item) => `
              <div class="migrate-item migrate-dedup">
                <div><strong>${item.id || '—'}</strong> • ${item.ts || '—'}</div>
                <div class="muted">Duplikat do scalenia.</div>
              </div>
            `).join('');
          } else {
            const grouped = new Map();
            items.forEach((item) => {
              const key = item.id || '—';
              if (!grouped.has(key)) grouped.set(key, []);
              grouped.get(key).push(item);
            });
            const blocks = [];
            grouped.forEach((groupItems, id) => {
              const header = `<div class="migrate-group-title"><strong>${id}</strong> • ${groupItems.length} wpisów</div>`;
              const rows = groupItems.map((item) => `
                <div class="migrate-item">
                  <div><strong>${item.id || '—'}</strong> • ${item.ts || '—'}</div>
                  <div class="muted migrate-before">${formatPreviewValue(item.before)}</div>
                  <div class="muted migrate-after">${formatPreviewValue(item.after)}</div>
                </div>
              `).join('');
              blocks.push(`<div class="migrate-group">${header}${rows}</div>`);
            });
            migrateLogsList.innerHTML = blocks.join('');
          }
        }
      } catch (error) {
        if (migrateLogsSummary) {
          migrateLogsSummary.textContent = 'Nie udało się pobrać podglądu.';
        }
      }
    }

    if (migrateLogsClose) migrateLogsClose.addEventListener('click', closeMigrateLogsModal);
    if (migrateLogsCancel) migrateLogsCancel.addEventListener('click', closeMigrateLogsModal);
    if (migrateLogsApply) {
      migrateLogsApply.addEventListener('click', async () => {
        if (!migrateLogsSummary) return;
        migrateLogsSummary.textContent = 'Wykonuję migrację…';
        try {
          const currentVersion = await resolveCurrentAppVersion();
          const dedup = false;
          const resp = await window.PN_MAPPINGS_API.request('/migrate-logs', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              version: currentVersion,
              dedup,
              mode: migrateMode,
              apply: true
            })
          });
          if (!resp.ok) {
            const text = await resp.text().catch(() => '');
            throw new Error(`HTTP ${resp.status}${text ? `: ${text}` : ''}`);
          }
          const data = await resp.json();
          const count = Number(data.updated) || 0;
          migrateLogsSummary.textContent = `Zaktualizowano: ${count}.`;
          showToast('Migracja zakończona.', 'ok');
          fetchLogs({ notifySuccess: true });
          fetchReports();
        } catch (error) {
          migrateLogsSummary.textContent = 'Migracja nieudana.';
          showToast('Nie udało się wykonać migracji.', 'warn');
        }
      });
    }

    setInterval(() => {
      fetchLogs();
      fetchReports();
    }, 30000);

  </script>
</body>
</html>
